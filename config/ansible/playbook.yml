---
- name: Provision Universal Staging Box
  hosts: localhost
  connection: local
  become: true
  handlers:
    - name: restart docker
      service:
        name: docker
        state: restarted
  vars:
    # --- CONFIGURATION (Reads from /etc/infra_config.env) ---
    # We use 'type=properties' to read the file even without [headers]
    infra_conf: "{{ lookup('ini', 'ECR_URL type=properties file=/etc/infra_config.env') }}"
    project_root: "{{ lookup('ini', 'PROJECT_ROOT type=properties file=/etc/infra_config.env') }}"
    db_pass: "{{ lookup('ini', 'ROOT_DB_PASS type=properties file=/etc/infra_config.env') }}"
    oci_region: "{{ lookup('ini', 'OCI_REGION type=properties file=/etc/infra_config.env') | default('us-east-1', true) }}"
    # Infer AWS region only when using ECR; otherwise fall back to OCI region
    aws_region: "{{ infra_conf.split('.')[3] if ('dkr.ecr' in infra_conf) else oci_region }}"
    # Hardcode your domain here OR pass it via Terraform/User Data
    root_domain: "teamcanvas.site"
    # Detect cloud provider from ECR URL pattern
    # AWS: *.dkr.ecr.*.amazonaws.com
    # OCI: *.ocir.io
    is_aws: "{{ 'dkr.ecr' in infra_conf }}"
    is_oci: "{{ 'ocir.io' in infra_conf }}"
    # Load apps configuration
    apps_config: "{{ lookup('file', project_root + '/config/apps-config.yml') | from_yaml | default({'apps': []}, true) }}"
    # Project name for SSM paths (default to 'staging', can be overridden)
    project_name: "{{ lookup('ini', 'PROJECT_NAME type=properties file=/etc/infra_config.env') | default('staging', true) }}"

  tasks:
    # --- 1. SYSTEM PRE-REQUISITES ---
    - name: Install System Dependencies
      apt:
        pkg: [ca-certificates, curl, gnupg, unzip, python3-pip, acl]
        state: present
        update_cache: yes

    # --- 2. INSTALL AWS CLI v2 (The Official Way) ---
    - name: Check if AWS CLI v2 is installed
      stat:
        path: /usr/local/bin/aws
      register: aws_cli_bin
      when: is_aws | bool

    - name: Download and Install AWS CLI v2
      shell: |
        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
        unzip -o /tmp/awscliv2.zip -d /tmp
        /tmp/aws/install --update
      when:
        - is_aws | bool
        - not aws_cli_bin.stat.exists

    # --- 3. INSTALL DOCKER (The Official Way) ---
    - name: Create Keyring Directory
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: "0755"

    - name: Add Docker GPG Key
      get_url:
        url: https://download.docker.com/linux/ubuntu/gpg
        dest: /etc/apt/keyrings/docker.asc
        mode: "0644"

    - name: Add Docker Repository
      apt_repository:
        repo: "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        filename: docker
        state: present

    - name: Install Docker Engine
      apt:
        pkg:
          [
            docker-ce,
            docker-ce-cli,
            containerd.io,
            docker-buildx-plugin,
            docker-compose-plugin,
          ]
        state: present
        update_cache: yes

    - name: Start Docker Service
      service: name=docker state=started enabled=yes

    - name: Add ubuntu user to docker group
      user: name=ubuntu groups=docker append=yes

    # --- 3.5. CREATE DEPLOY USER ---
    - name: Create deploy user
      user:
        name: deploy
        groups: docker,sudo
        shell: /bin/bash
        create_home: yes
        home: /home/deploy
        comment: "Deployment user for staging environment"

    - name: Set up deploy user SSH directory
      file:
        path: /home/deploy/.ssh
        state: directory
        owner: deploy
        group: deploy
        mode: "0700"

    - name: Add deploy user to sudoers (passwordless for deployment tasks)
      lineinfile:
        path: /etc/sudoers.d/deploy
        line: "deploy ALL=(ALL) NOPASSWD: /usr/bin/docker, /usr/bin/docker-compose, /usr/local/bin/docker-compose"
        create: yes
        mode: "0440"
        validate: "visudo -cf %s"

    # --- 3.6. SSH SECURITY HARDENING ---
    - name: Disable root login via SSH
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^#?PermitRootLogin"
        line: "PermitRootLogin no"
        backup: yes

    - name: Disable password authentication (SSH keys only)
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^#?PasswordAuthentication"
        line: "PasswordAuthentication no"
        backup: yes

    - name: Restart SSH service
      service:
        name: ssh
        state: restarted
        enabled: yes

    # --- 3.7. FIREWALL CONFIGURATION (UFW) ---
    - name: Install UFW
      apt:
        name: ufw
        state: present

    - name: Set UFW default policies
      ufw:
        direction: "{{ item.direction }}"
        policy: "{{ item.policy }}"
      loop:
        - { direction: "incoming", policy: "deny" }
        - { direction: "outgoing", policy: "allow" }

    - name: Allow HTTP
      ufw:
        rule: allow
        port: "80"
        proto: tcp

    - name: Allow HTTPS
      ufw:
        rule: allow
        port: "443"
        proto: tcp

    - name: Allow SSH (OCI only)
      ufw:
        rule: allow
        port: "22"
        proto: tcp
      when: is_oci | bool

    - name: Enable UFW
      ufw:
        state: enabled

    # Note: On AWS, SSH (22) remains blocked at UFW level; use SSM.

    # --- 3.8. DOCKER LOG ROTATION CONFIGURATION ---
    - name: Create Docker daemon.json directory
      file:
        path: /etc/docker
        state: directory
        mode: "0755"

    - name: Configure Docker log rotation in daemon.json
      copy:
        content: |
          {
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "10m",
              "max-file": "3"
            }
          }
        dest: /etc/docker/daemon.json
        mode: "0644"
      notify: restart docker

    # # --- 3.9. AWS SSM AGENT VERIFICATION ---

    # # 1. Check if installed via Snap (Default on Ubuntu)
    # - name: Check if SSM agent is installed via Snap
    #   command: snap list amazon-ssm-agent
    #   register: snap_check
    #   failed_when: false
    #   changed_when: false
    #   when: is_aws | bool

    # # 2. Case A: If Snap is present, ensure it is running
    # - name: Ensure Snap SSM agent is started
    #   service:
    #     name: snap.amazon-ssm-agent.amazon-ssm-agent
    #     state: started
    #     enabled: yes
    #   when:
    #     - is_aws | bool
    #     - snap_check.rc == 0
    #   failed_when: false # Ignore if service name differs slightly

    # # 3. Case B: If Snap is MISSING, check if standard service exists
    # - name: Check if standard SSM agent is active
    #   command: systemctl is-active amazon-ssm-agent
    #   register: standard_ssm_status
    #   failed_when: false
    #   changed_when: false
    #   check_mode: no
    #   when:
    #     - is_aws | bool
    #     - snap_check.rc != 0

    # # 4. Case B: Download .deb ONLY if neither Snap nor Standard version exists
    # - name: Download SSM Agent
    #   get_url:
    #     url: https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_amd64/amazon-ssm-agent.deb
    #     dest: /tmp/amazon-ssm-agent.deb
    #     mode: '0644'
    #   when:
    #     - is_aws | bool
    #     - snap_check.rc != 0
    #     - standard_ssm_status.rc != 0

    # # 5. Case B: Install .deb
    # - name: Install SSM Agent (.deb)
    #   apt:
    #     deb: /tmp/amazon-ssm-agent.deb
    #     state: present
    #   when:
    #     - is_aws | bool
    #     - snap_check.rc != 0
    #     - standard_ssm_status.rc != 0

    # # 6. Case B: Cleanup
    # - name: Remove temporary installer
    #   file:
    #     path: /tmp/amazon-ssm-agent.deb
    #     state: absent
    #   when:
    #     - is_aws | bool
    #     - snap_check.rc != 0
    #     - standard_ssm_status.rc != 0

    # # 7. Case B: Start standard service
    # - name: Ensure Standard SSM agent is enabled and started
    #   systemd:
    #     name: amazon-ssm-agent
    #     state: started
    #     enabled: yes
    #     daemon_reload: yes
    #   when:
    #     - is_aws | bool
    #     - snap_check.rc != 0

    # --- 4. ORCHESTRATION SETUP ---
    - name: Create Directories
      file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
        owner: deploy
        group: deploy
      loop:
        - "{{ project_root }}/orchestration/env"
        - "{{ project_root }}/orchestration/caddy_data"

    # --- 5. CONFIGURATION FIXES ---
    - name: Generate Production .env file
      copy:
        content: |
          # Generated by Ansible
          ECR_URL={{ infra_conf }}
          DOMAIN_NAME={{ root_domain }}
          AWS_REGION={{ aws_region }}
          # OCI Logging variables (used only on OCI)
          OCI_TENANCY_OCID={{ lookup('ini', 'OCI_TENANCY_OCID type=properties file=/etc/infra_config.env') | default('', true) }}
          OCI_COMPARTMENT_OCID={{ lookup('ini', 'OCI_COMPARTMENT_OCID type=properties file=/etc/infra_config.env') | default('', true) }}
          OCI_LOG_ID={{ lookup('ini', 'OCI_LOG_ID type=properties file=/etc/infra_config.env') | default('', true) }}
          # Office IP for Caddy IP whitelist (update this with your actual office IP)
          OFFICE_IP=<YOUR_OFFICE_IP>
        dest: "{{ project_root }}/orchestration/.env"
        owner: deploy
        group: deploy
        mode: "0600"

    - name: Update Caddyfile Office IP Placeholder
      replace:
        path: "{{ project_root }}/orchestration/Caddyfile"
        regexp: "<YOUR_OFFICE_IP>"
        replace: "{{ lookup('ini', 'OFFICE_IP type=properties file=/etc/infra_config.env') | default('CHANGE_ME', true) }}"
      # Note: Office IP should be set in /etc/infra_config.env or Terraform variables
      failed_when: false # Don't fail if placeholder not found

    # --- 6. FETCH APPLICATION SECRETS FROM SSM/OCI VAULT ---
    - name: Check if apps are configured
      debug:
        msg: "Found {{ apps_config.apps | length }} app(s) to fetch secrets for: {{ apps_config.apps | map(attribute='name') | join(', ') }}"
      when: apps_config.apps | length > 0

    # -------------------------------------------------------
    # AWS IMPLEMENTATION (Unrolled Block)
    # -------------------------------------------------------
    - name: Fetch secrets from AWS SSM Parameter Store
      shell: |
        aws ssm get-parameter \
          --name "/{{ project_name }}/{{ item.name }}/env" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text \
          --region {{ aws_region }}
      loop: "{{ apps_config.apps }}"
      loop_control:
        label: "{{ item.name }}"
      register: ssm_secrets
      when: is_aws | bool and apps_config.apps | length > 0
      no_log: true
      failed_when: false
      changed_when: false

    - name: Write .env file for apps (AWS)
      copy:
        content: "{{ item.stdout }}"
        dest: "{{ project_root }}/orchestration/env/{{ item.item.name }}.env"
        owner: deploy
        group: deploy
        mode: "0600"
      loop: "{{ ssm_secrets.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      when:
        - is_aws | bool
        - item.rc is defined
        - item.rc == 0
      no_log: true

    - name: Warn if secret not found (AWS)
      debug:
        msg: "WARNING: Secret /{{ project_name }}/{{ item.item.name }}/env not found in SSM. Skipping .env file creation. Upload it manually or the app will fail to start."
      loop: "{{ ssm_secrets.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      when:
        - is_aws | bool
        - item.rc is defined
        - item.rc != 0

    # -------------------------------------------------------
    # OCI IMPLEMENTATION (Unrolled Block)
    # -------------------------------------------------------
    - name: Fetch secrets from OCI Vault
      shell: |
        oci secrets secret-bundle get \
          --secret-id "{{ lookup('ini', 'OCI_SECRET_' + item.name.upper() + '_OCID type=properties file=/etc/infra_config.env') }}" \
          --auth instance_principal \
          --query 'data."secret-bundle-content".content' \
          --raw-output | base64 -d
      loop: "{{ apps_config.apps }}"
      loop_control:
        label: "{{ item.name }}"
      register: oci_secrets
      vars:
        # Check if the secret ID exists before running
        secret_id: "{{ lookup('ini', 'OCI_SECRET_' + item.name.upper() + '_OCID type=properties file=/etc/infra_config.env') }}"
      when:
        - is_oci | bool
        - apps_config.apps | length > 0
        - secret_id | length > 0
      no_log: true
      failed_when: false
      changed_when: false

    - name: Write .env file for apps (OCI)
      copy:
        content: "{{ item.stdout }}"
        dest: "{{ project_root }}/orchestration/env/{{ item.item.name }}.env"
        owner: deploy
        group: deploy
        mode: "0600"
      loop: "{{ oci_secrets.results }}"
      loop_control:
        label: "{{ item.item.name }}"
      when:
        - is_oci | bool
        - item.skipped is not defined
        - item.rc == 0
      no_log: true

    - name: Warn if OCI secret OCID not configured
      debug:
        msg: "WARNING: OCI_SECRET_{{ item.name.upper() }}_OCID not found in /etc/infra_config.env. Skipping .env file creation."
      loop: "{{ apps_config.apps }}"
      loop_control:
        label: "{{ item.name }}"
      vars:
        secret_id: "{{ lookup('ini', 'OCI_SECRET_' + item.name.upper() + '_OCID type=properties file=/etc/infra_config.env') }}"
      when:
        - is_oci | bool
        - secret_id | length == 0

    # --- 7. AUTHENTICATION & STARTUP ---
    - name: Login to AWS ECR
      shell: |
        aws ecr get-login-password --region {{ aws_region }} | docker login --username AWS --password-stdin {{ infra_conf }}
      register: ecr_login
      retries: 3
      delay: 5
      until: ecr_login.rc == 0
      become_user: deploy

    - name: Set ownership of orchestration directory to deploy user
      file:
        path: "{{ project_root }}/orchestration"
        owner: deploy
        group: deploy
        recurse: yes

    - name: Select Fluent Bit config for AWS
      copy:
        src: "{{ project_root }}/orchestration/fluent-bit.conf"
        dest: "{{ project_root }}/orchestration/fluent-bit.conf"
      when: is_aws | bool

    - name: Select Fluent Bit config for OCI
      copy:
        src: "{{ project_root }}/orchestration/fluent-bit-oci.conf"
        dest: "{{ project_root }}/orchestration/fluent-bit.conf"
      when: is_oci | bool

    - name: Start Infrastructure (Caddy, Fluent Bit, and Dozzle - DB is external RDS/OCI Autonomous)
      shell: |
        docker compose up -d caddy fluent-bit dozzle
      args:
        chdir: "{{ project_root }}/orchestration"
      become_user: deploy
